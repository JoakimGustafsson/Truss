<!DOCTYPE html>
<html lang=en>
<!--
  This application demonstrates using Pointer Events for simple 2-pointer
  pinch/zoom gesture recognition.
-->

<link rel="stylesheet" type="text/css" href="../Stylefiles/Truss.css">

<head>
  <title>Pointer Events pinch/zoom example</title>
  <meta name="viewport" content="width=device-width">
  <style>
    .zoomArea {
      position: relative;
      overflow: hidden;
      border: 1px solid grey;
    }

    .zoomable {
      z-index: 99;
      position: absolute;
    }

    .selectorScreen {
      height: 100%;
      width: 100%;
      position: absolute;
      z-index: 100;
      background-color: transparent;
    }
  </style>
</head>

<script>

  class View {
    constructor(scale) {
      this.view = {
        worldViewScale: {
          x: scale,
          y: scale
        },
        offset: {
          x: 0,
          y: 0
        }
      }

      this.screenPointerPositionX = 0;
      this.screenPointerPositionY = 0;
      this.graphicObjects = [];
    }
    //returns the screenposition of a world object
    viewScreenPosition(objectWorldPosition) {
      return [(objectWorldPosition.x - this.view.offset.x) * this.view.worldViewScale.x, (objectWorldPosition.y - this
          .view.offset.y) *
        this.view.worldViewScale.y
      ];
    }
    //returns the world position of screen cordinates
    worldPosition(screenPosition) {
      return {
        x: screenPosition.x / this.view.worldViewScale.x + this.view.offset.x,
        y: screenPosition.y / this.view.worldViewScale.y + this.view.offset.y
      };
    }
    // after scale size change the offset should be updated
    updateOffset(mouseScreenPanning) {
      this.view.offset.x += mouseScreenPanning.x / this.view.worldViewScale.x;
      this.view.offset.y += mouseScreenPanning.y / this.view.worldViewScale.y;
    }
    // after panning the offset should be updated
    updateScale(deltaScaleOnScreen, center) {
      this.view.worldViewScale.x -= deltaScaleOnScreen.x * this.view.worldViewScale.x;
      this.view.worldViewScale.y -= deltaScaleOnScreen.y * this.view.worldViewScale.y;

      this.view.offset.x -= (center.x - this.view.offset.x) * deltaScaleOnScreen.x;
      this.view.offset.y -= (center.y - this.view.offset.y) * deltaScaleOnScreen.y;
    }

    HandleView() {
      let targetWidth = el.offsetWidth;
      let targetHeight = el.offsetHeight;
      for (let graphicObject of this.graphicObjects) {
        let [newX, newY] = this.viewScreenPosition(graphicObject)
        graphicObject.object.style.left = newX + 'px';
        graphicObject.object.style.top = newY + 'px';
        graphicObject.object.style.width = graphicObject.width * this.view.worldViewScale.x + 'px';
        graphicObject.object.style.height = graphicObject.height * this.view.worldViewScale.y + 'px';
      }
    }


    addGraphicObject(newObject) {
      this.graphicObjects.push({
        x: newObject.offsetLeft / this.view.worldViewScale.x,
        y: newObject.offsetTop / this.view.worldViewScale.y,
        width: newObject.offsetWidth / this.view.worldViewScale.x,
        height: newObject.offsetHeight / this.view.worldViewScale.y,
        object: newObject
      })
    }

  }




  // Global vars to cache event state
  var evCache = new Array();
  var prevDiff = -1;
  var keepRatio = true;


  let lastScreenPosition = undefined;

  let mouseDown = false;


  function pointerdown_handler(ev) {
    // The pointerdown event signals the start of a touch interaction.
    // This event is cached to support 2-finger gestures
    evCache.push(ev);

    mouseDown = true;
    lastScreenPosition = undefined;
    lastScreenScale = undefined;
  }

  function pointermove_handler(ev) {
    // This function implements a 2-pointer horizontal pinch/zoom gesture. 
    //
    // If the distance between the two pointers has increased (zoom in), 
    // the taget element's background is changed to "pink" and if the 
    // distance is decreasing (zoom out), the color is changed to "lightblue".
    //
    // This function sets the target element's border to "dashed" to visually
    // indicate the pointer's target received a move event.

    // Find this event in the cache and update its record with this event
    for (var i = 0; i < evCache.length; i++) {
      if (ev.pointerId == evCache[i].pointerId) {
        evCache[i] = ev;
        break;
      }
    }
    let top;
    let left;
    // If two pointers are down, check for pinch gestures
    if (evCache.length == 2) {
      // Calculate the distance between the two pointers
      var curDiff = Math.abs(evCache[0].clientX - evCache[1].clientX);
      // Cache the distance for the next move event 
      prevDiff = curDiff;
      top = Math.min(evCache[1].pageY, evCache[0].pageY);
      let bottom = Math.max(evCache[1].pageY, evCache[0].pageY);
      left = Math.min(evCache[1].pageX, evCache[0].pageX);
      let right = Math.max(evCache[1].pageX, evCache[0].pageX);

      widthPosition = right - left;
      heightPosition = bottom - top;
      screenPointerPositionX = left + widthPosition / 2;
      screenPointerPositionY = top + heightPosition / 2;
    } else {
      top = ev.pageY;
      left = ev.pageX;
      screenPointerPositionX = left;
      screenPointerPositionY = top;
    }

    if (mouseDown) {
      if (lastScreenPosition) {
        newView.updateOffset({
          x: lastScreenPosition.x - screenPointerPositionX,
          y: lastScreenPosition.y - screenPointerPositionY
        });
      }
      lastScreenPosition = {
        x: screenPointerPositionX,
        y: screenPointerPositionY
      }

      // If two pointers are down, check for pinch gestures
      if (evCache.length == 2) {
        if (mouseDown) {
          if (lastScreenScale) {
            let xValue = (lastScreenScale.width - widthPosition) / lastScreenScale.width;
            let yValue = (lastScreenScale.height - heightPosition) / lastScreenScale.height;
            if (keepRatio) {
              if (widthPosition > heightPosition) {
                yValue = xValue;
              } else {
                xValue = yValue;
              }
            }
            newView.updateScale({
              x: xValue,
              y: yValue,
            }, newView.worldPosition({
              x: screenPointerPositionX,
              y: screenPointerPositionY
            }));
          }
          lastScreenScale = {
            width: widthPosition,
            height: heightPosition
          }
        }
      }
    }
    newView.HandleView();
  }


  function mousewheel_handler(ev) {
    let e = window.event || ev; // old IE support
    e.preventDefault();
    let delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail)));
    newView.updateScale({
      x: delta * -0.1,
      y: delta * -0.1,
    }, newView.worldPosition({
      x: screenPointerPositionX,
      y: screenPointerPositionY
    }));
    newView.HandleView();
  }

  function pointerup_handler(ev) {
    // Remove this pointer from the cache and reset the target's
    // background and border
    remove_event(ev);

    // If the number of pointers down is less than two then reset diff tracker
    if (evCache.length < 2) prevDiff = -1;
    if (evCache.length == 0) {
      mouseDown = false;
    }

    screenPointerPositionX = 0;
    screenPointerPositionY = 0;

    lastScreenPosition = undefined;
    //console.log('up offset: ' + view.offset.x + ', ' + view.offset.y);
  }

  function remove_event(ev) {
    // Remove this event from the target's cache
    for (var i = 0; i < evCache.length; i++) {
      if (evCache[i].pointerId == ev.pointerId) {
        evCache.splice(i, 1);
        break;
      }
    }
  }


  var el;
  var newView;

  function init() {
    // Install event handlers for the pointer target
    el = document.getElementById("targetZoom");
    el.onpointerdown = pointerdown_handler;
    el.onpointermove = pointermove_handler;
    // Use same handler for pointer{up,cancel,out,leave} events since
    // the semantics for these events - in this app - are the same.
    el.onpointerup = pointerup_handler;
    el.onpointercancel = pointerup_handler;
    el.onpointerout = pointerup_handler;
    el.onpointerleave = pointerup_handler;
    el.onmousewheel = mousewheel_handler;
    el.mousewheel = mousewheel_handler;
    el.dommousewheel = mousewheel_handler;

    newView = new View(10);

    for (let elZoom of document.getElementsByClassName("zoomable")) {
      newView.addGraphicObject(elZoom);
    }

  }
</script>

<body onload="init();" style="touch-action:none">
  Zoom and Pan using mouse or touch
  <div id="limiter" class="zoomArea" style="height:800px; width:500px;">
    <div id="targetZoom" class="noselect selectorScreen">

    </div>
    <img id="pic" class="zoomable" style="left:10px; top:10px; width:100px; height:100px;"
      src='\Resources\BlueYellow.jpg'>
    <img id="pic2" class="zoomable" style="left:100px; top:100px;  width:150px; height:150px;"
      src='\Resources\BlueYellow.jpg'>
  </div>
  <output></output>
</body>

</html>