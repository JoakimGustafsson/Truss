<!DOCTYPE html>
<html lang=en>
<!--
  This application demonstrates using Pointer Events for simple 2-pointer
  pinch/zoom gesture recognition.
-->

<link rel="stylesheet" type="text/css" href="../Stylefiles/Truss.css">

<head>
  <title>Pointer Events pinch/zoom example</title>
  <meta name="viewport" content="width=device-width">
  <style>
    .zoomArea {
      position: relative;
      overflow: hidden;
      border: 1px solid grey;
    }

    .zoomable {
      z-index: 99;
      position: absolute;
    }

    .selectorScreen {
      height: 100%;
      width: 100%;
      position: absolute;
      z-index: 100;
      background-color: transparent;
    }
  </style>
</head>

<script>
  class View {
    constructor(scale) {
      this.view = {
        worldViewScale: {
          x: scale,
          y: scale
        },
        offset: {
          x: 0,
          y: 0
        }
      }

      this.screenPointerPositionX = 0;
      this.screenPointerPositionY = 0;
      this.graphicObjects = [];
    }
    //returns the screenposition of a world object
    viewScreenPosition(objectWorldPosition) {
      return [(objectWorldPosition.x - this.view.offset.x) * this.view.worldViewScale.x, (objectWorldPosition.y - this
          .view.offset.y) *
        this.view.worldViewScale.y
      ];
    }
    //returns the world position of screen cordinates
    worldPosition(screenPosition) {
      return {
        x: screenPosition.x / this.view.worldViewScale.x + this.view.offset.x,
        y: screenPosition.y / this.view.worldViewScale.y + this.view.offset.y
      };
    }
    // after scale size change the offset should be updated
    updateOffset(mouseScreenPanning) {
      this.view.offset.x += mouseScreenPanning.x / this.view.worldViewScale.x;
      this.view.offset.y += mouseScreenPanning.y / this.view.worldViewScale.y;
    }
    // after panning the offset should be updated
    updateScale(deltaScaleOnScreen, center) {
      this.view.worldViewScale.x -= deltaScaleOnScreen.x * this.view.worldViewScale.x;
      this.view.worldViewScale.y -= deltaScaleOnScreen.y * this.view.worldViewScale.y;

      this.view.offset.x -= (center.x - this.view.offset.x) * deltaScaleOnScreen.x;
      this.view.offset.y -= (center.y - this.view.offset.y) * deltaScaleOnScreen.y;
    }

    HandleView() {
      //let targetWidth = el.offsetWidth;
      //let targetHeight = el.offsetHeight;
      for (let graphicObject of this.graphicObjects) {
        let [newX, newY] = this.viewScreenPosition(graphicObject)
        graphicObject.object.style.left = newX + 'px';
        graphicObject.object.style.top = newY + 'px';
        graphicObject.object.style.width = graphicObject.width * this.view.worldViewScale.x + 'px';
        graphicObject.object.style.height = graphicObject.height * this.view.worldViewScale.y + 'px';
      }
    }


    addGraphicObject(newObject) {
      this.graphicObjects.push({
        x: newObject.offsetLeft / this.view.worldViewScale.x,
        y: newObject.offsetTop / this.view.worldViewScale.y,
        width: newObject.offsetWidth / this.view.worldViewScale.x,
        height: newObject.offsetHeight / this.view.worldViewScale.y,
        object: newObject
      })
    }

  }


  class PanZoomHandler {
    constructor(sensorElement, view) {
      this.view = view;

      // Install event handlers for the pointer target
      sensorElement.onpointerdown = (ev) => {this.pointerdown_handler(ev);};
      sensorElement.onpointermove = (ev) => {this.pointermove_handler(ev);};
      // Use same handler for pointer{up,cancel,out,leave} events since
      // the semantics for these events - in this app - are the same.
      sensorElement.onpointerup = (ev) => {this.pointerup_handler(ev);};
      sensorElement.onpointercancel = (ev) => {this.pointerup_handler(ev);};
      sensorElement.onpointerout = (ev) => {this.pointerup_handler(ev);};
      sensorElement.onpointerleave = (ev) => {this.pointerup_handler(ev);};
      sensorElement.onmousewheel = (ev) => {this.mousewheel_handler(ev);};
      sensorElement.mousewheel = (ev) => {this.mousewheel_handler(ev);};
      sensorElement.dommousewheel = (ev) => {this.mousewheel_handler(ev);};


      // Global vars to cache event state
      this.evCache = new Array();
      this.prevDiff = -1;
      this.keepRatio = true;

      this.lastScreenPosition = undefined;

      this.mouseDown = false;
    }



  pointerdown_handler(ev) {
    // The pointerdown event signals the start of a touch interaction.
    // This event is cached to support 2-finger gestures
    this.evCache.push(ev);

    this.mouseDown = true;
    this.lastScreenPosition = undefined;
    this.lastScreenScale = undefined;
  }


  pointermove_handler(ev) {
    // This function implements a 2-pointer horizontal pinch/zoom gesture. 
    //
    // If the distance between the two pointers has increased (zoom in), 
    // the taget element's background is changed to "pink" and if the 
    // distance is decreasing (zoom out), the color is changed to "lightblue".
    //
    // This function sets the target element's border to "dashed" to visually
    // indicate the pointer's target received a move event.

    // Find this event in the cache and update its record with this event
    for (var i = 0; i < this.evCache.length; i++) {
      if (ev.pointerId == this.evCache[i].pointerId) {
        this.evCache[i] = ev;
        break;
      }
    }
    let top;
    let left;
    let widthPosition;
    let heightPosition;
    // If two pointers are down, check for pinch gestures
    if (this.evCache.length == 2) {
      // Calculate the distance between the two pointers
      var curDiff = Math.abs(this.evCache[0].clientX - this.evCache[1].clientX);
      // Cache the distance for the next move event 
      this.prevDiff = curDiff;
      top = Math.min(this.evCache[1].pageY, this.evCache[0].pageY);
      let bottom = Math.max(this.evCache[1].pageY, this.evCache[0].pageY);
      left = Math.min(this.evCache[1].pageX, this.evCache[0].pageX);
      let right = Math.max(this.evCache[1].pageX, this.evCache[0].pageX);

       widthPosition = right - left;
       heightPosition = bottom - top;
      this.screenPointerPositionX = left + widthPosition / 2;
      this.screenPointerPositionY = top + heightPosition / 2;
    } else {
      top = ev.pageY;
      left = ev.pageX;
      this.screenPointerPositionX = left;
      this.screenPointerPositionY = top;
    }

    if (this.mouseDown) {
      if (this.lastScreenPosition) {
        this.view.updateOffset({
          x: this.lastScreenPosition.x - this.screenPointerPositionX,
          y: this.lastScreenPosition.y - this.screenPointerPositionY
        });
      }
      this.lastScreenPosition = {
        x: this.screenPointerPositionX,
        y: this.screenPointerPositionY
      }

      // If two pointers are down, check for pinch gestures
      if (this.evCache.length == 2) {
        if (this.mouseDown) {
          if (this.lastScreenScale) {
            let xValue = (this.lastScreenScale.width - widthPosition) / this.lastScreenScale.width;
            let yValue = (this.lastScreenScale.height - heightPosition) / this.lastScreenScale.height;
            if (this.keepRatio) {
              if (widthPosition > heightPosition) {
                yValue = xValue;
              } else {
                xValue = yValue;
              }
            }
            this.view.updateScale({
              x: xValue,
              y: yValue,
            }, this.view.worldPosition({
              x: this.screenPointerPositionX,
              y: this.screenPointerPositionY
            }));
          }
          this.lastScreenScale = {
            width: widthPosition,
            height: heightPosition
          }
        }
      }
    }
    this.view.HandleView();
  }


  mousewheel_handler(ev) {
    let e = window.event || ev; // old IE support
    e.preventDefault();
    let delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail)));
    this.view.updateScale({
      x: delta * -0.1,
      y: delta * -0.1,
    }, this.view.worldPosition({
      x: this.screenPointerPositionX,
      y: this.screenPointerPositionY
    }));
    this.view.HandleView();
  }

  pointerup_handler(ev) {
    // Remove this pointer from the cache and reset the target's
    // background and border
    this.remove_event(ev);

    // If the number of pointers down is less than two then reset diff tracker
    if (this.evCache.length < 2) this.prevDiff = -1;
    if (this.evCache.length == 0) {
      this.mouseDown = false;
    }

    this.screenPointerPositionX = 0;
    this.screenPointerPositionY = 0;

    this.lastScreenPosition = undefined;
    //console.log('up offset: ' + view.offset.x + ', ' + view.offset.y);
  }

  remove_event(ev) {
    // Remove this event from the target's cache
    for (var i = 0; i < this.evCache.length; i++) {
      if (this.evCache[i].pointerId == ev.pointerId) {
        this.evCache.splice(i, 1);
        break;
      }
    }
  }
}

  function init() {
   let newView = new View(10);
    newPanZoomHandler = new PanZoomHandler(document.getElementById("targetZoom"), newView);
    for (let elZoom of document.getElementsByClassName("zoomable")) {
      newView.addGraphicObject(elZoom);
    }

  }
</script>

<body onload="init();" style="touch-action:none">
  Zoom and Pan using mouse or touch
  <div id="limiter" class="zoomArea" style="height:800px; width:500px;">
    <div id="targetZoom" class="noselect selectorScreen">

    </div>
    <img id="pic" class="zoomable" style="left:10px; top:10px; width:100px; height:100px;"
      src='\Resources\BlueYellow.jpg'>
    <img id="pic2" class="zoomable" style="left:100px; top:100px;  width:150px; height:150px;"
      src='\Resources\BlueYellow.jpg'>
  </div>
  <output></output>
</body>

</html>